---
title: CSAPP
tags: [计算机系统]
categories: [软件]
math: true #是否启用数学公式
---

## 第一章 计算机系统漫游

### 系统的硬件组成

1. **总线**：总线是一组贯穿整个系统的电子管道，它携带信息字节并负责在各个部件之间传递。通常总线被设计成**传递定长的字节块**，也就是**字（word）**。字中的字节数（即字长）是一个基本的系统参数，各个系统都不尽相同，现在大多的机器要么是4个字节（32位），要么是8个字节（64）位。
2. **I/O设备**：I/O设备是系统与外部世界的联系通道，基本的I/O设备有：作为用户输入的鼠标和键盘、作为用户输出的显示器、以及作为长期储存数据和程序的磁盘。每个I/O设备都通过一个控制器或者适配器与I/O总线相连，它们的区别主要在于它们的封装方式，且它们的功能都是在I/O设备和I/O总线之间传递信息。
3. **主存**：主存是临时存储设备，用来存放程序和程序处理的数据。物理上来说，主存是由一组**随机动态存储器（DRAM）**芯片组成的。逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址，这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。
4. **处理器**：中央处理器是解释或执行存储在主存中的指令的引擎。处理器的核心是一个大小为一个字的存储设备（寄存器），称为**程序计数器（PC）**。在任何时刻，PC都指向主存中某条机器指令（即含有该指令的地址）。

### 高速缓存

根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为高**速缓存存储器（cache memory）**，暂时作为集结的区域，存放近期可能会需要的信息。高速缓存是用一种叫**静态随机访问存储器（SRAM）**的硬件技术实现的。

### 操作系统管理硬件
当系统加载程序时，程序都没有直接访问键盘、显示器、磁盘或主存。取而代之的是，它们依靠操作系统提供的服务，我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，所以应用程序对硬件的操作尝试都必须通过操作系统。操作系统有两个基本的功能：1. 防止硬件被失控的应用程序滥用；2. 向应用程序提供简单一致的机制来控制复杂而通常又大不相同的硬件设备。操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。**文件是对I/O设备的抽象表示，虚拟内存是对I/O设备和主存的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。**
1. **进程**：进程是操作系统对**一个正在运行的程序**的一种抽象。在一个系统上可以同时运行多个进程，而每个进程好像在独占的使用硬件。而**并发运行**，则是说一个进程的指令和另一个进程的指令是交错执行的。无论是单核还是多核系统，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程之间的的切换实现的。操作系统实现这种交错执行的机制称为**上下文切换**。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文，恢复新进程的上下文，然后将控制权传递到新进程。从一个进程到另一个进程的转换是由**操作系统内核（kernel）**管理的。
2. **线程**：一个进程实际上是由多个称为线程的执行单元组成。
3. **虚拟内存**：虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存空间都是一样的，称为虚拟内存空间。
4. 文件：文件就是字节序列，每个I/O设备，包括磁盘、显示器，甚至是**网络**，都可以看成是文件。文件这个抽象概念为应用程序提供了一个统一的视图，来看待系统中可能含有的各式各样的I/O设备。

### 并发和并行

**并发（concurrency）**是指一个同时具有多个活动的系统，而**并行（parallelism）**指的是用**并发**来使系统运行的更快。并行可以在计算机系统的多个层次上运用。
1. **线程级并发**：传统意义上，这种并发只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换实现的。超线程，有时称为**同时多线程（simultaneous multi-threading）**，是一项允许一个CPU执行多个控制流的技术。
2. **指令级并行**：在较低抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。
3. **单指令、多数据并行**：在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。


## 第二章 信息的处理和表示

### IEEE浮点表示

IEEE浮点标准用 $n=(-1)^s*M*2^E$ 的形式来表示一个浮点数：

- **符号 s**（sign）：s 决定这个数是正数还是负数；
- **尾数 M**（mantissa）：M 是一个二进制小数，位于二进制串的末尾；
- **阶码 E**（exponent）：E 的作用是对浮点数加权，这个权重是2的 E 次幂（可能是负数）。

![浮点数表示](..\images\CSAPP\image1.png)

给定位表示，根据 E 的值，被编码的值可以分成三种不同的情况：

1. **规格化的值**：当 E 的位模式既不全为0，也不全为1（单精度数值为255，双精度数值为2047）时，都属于这类情况。这种情况中，**阶码字段**被解释为以**偏置**（biased）形式表示的有符号整数。也就是说，阶码的值是 $E=e-bias$，其中 $e$ 是无符号数，其位表示为 $e_{k-1}...e_1e_0$ ，而 $bias$ 是一个等于 $2^{k-1}-1$（单精度是127，双精度是1023，其中 k 是阶码位数）的偏置值。由此产生的指数的范围，对于单精度是-126 ~ +127，对于双精度是-1022 ~ +1023。 **小数字段**被解释为小数值 $f$ ，其中 $0<=f<1$ ，其二进制表示为 $0.f_{n-1}...f_1f_0$，也就是二进制小数点在最高有效位左边。尾数定义为 $M=1+f$，这种方式也叫做**隐含的以1开头的表示**，因为我们可以把 $M$ 看成是二进制 $1.f_{n-1}...f_1f_0$ 表达的数字，这种方法能够获得一个额外的精度，因为1不需要显示地表示出来。
2. **非规格化的值**：当阶码域全为 0 时，所表示的数是非规格化形式。在这种情况下，阶码值是 $E=1-bias$ ，而尾数的值是 $M=f$，也就是小数字段的值，不包含隐含开头的 1 。非规格化数提供了一种表示数值 0 的方法，因为规格化数字必须满足 $M>=1$ ，因此无法表示 0 。实际上，+0.0 的表示为：所有位都为0，而 -0.0 则符号位相反。
3. **特殊值**：最后一类数值是当阶码全为 1 的时候出现。当小数域为 0 的时候，得到的值是无穷（正无穷或负无穷）。当小数域非零时，结果值被称为 NaN（Not a Number）。
![8位浮点数的非负值实例](..\images\CSAPP\image2.png)

### 舍入

因为表示方法限制了浮点数的范围和精度，所以浮点数运算只能近似地表示实数运算。找到一个最近的匹配值就是**舍入运算**（rounding）的任务。IEEE 浮点格式定义了 4 种不同的舍入方式，分别是向**偶数舍入（四舍六入五取偶）、向零舍入、向上舍入和向下舍入**。向偶数舍入是默认的方式，规则是将数字向上或向下舍入，使得结果的最低有效位是偶数。



## 第三章 程序的机器级表示

计算机执行机器代码，用字节序列编码低级的操作。汇编代码是机器代码的文本表示，给出程序中的每一条指令。GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。编译器提供的类型检查能帮助我们发现许多程序错误，并能保证按照一致的方式来引用和处理数据。

机器级编程的两种抽象：1. 由 **指令集架构（Instruction Set Architecture，ISA）** 定义机器级程序的格式和行为，它定义了处理器的状态、指令的格式，以及每条指令对状态的影响；2. 机器级程序使用的内存是**虚拟内存**，提供的内存模型看上去像一个非常大的字节数组。

数据格式：

<table>
    <tr>
        <td>C声明</td>
        <td>Intel数据类型</td>
        <td>汇编代码后缀</td>
        <td>大小（字节）</td>
    </tr>
    <tr>
        <td>char</td>
        <td>字节</td>
        <td>b</td>
        <td>1</td>
    </tr>
    <tr>
        <td>short</td>
        <td>字</td>
        <td>w</td>
        <td>2</td>
    </tr>
    <tr>
        <td>int</td>
        <td>双字</td>
        <td>l</td>
        <td>4</td>
    </tr>
    <tr>
        <td>long</td>
        <td>四字</td>
        <td>q</td>
        <td>8</td>
    </tr>
    <tr>
        <td>char*</td>
        <td>四字</td>
        <td>q</td>
        <td>8</td>
    </tr>
    <tr>
        <td>float</td>
        <td>单精度</td>
        <td>s</td>
        <td>4</td>
    </tr>
    <tr>
        <td>double</td>
        <td>双精度</td>
        <td>l</td>
        <td>8</td>
    </tr>
</table>

一个x86-64的中央处理单元（CPU）包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储**整数数据**和**指针**。图中嵌套的方格表明，指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作。寄存器通常以符号‘%’开头。

当指令以寄存器作为目标时，生成 1 字节或 2 字节的指令会保持剩下的字节不变，而生成 4 字节数字的指令会把高位 4 个字节置0。

通常，编译器产生的代码中，会用一个寄存器存放多个程序值，还会在寄存器之间传送程序值。

![通用目的寄存器](..\images\CSAPP\image3.png)

### 访问信息

#### 操作数指示符

各种不同的操作数的可能性被分为3种类型：
   
1. **立即数（immediate）**：用来表示常数值，书写方式是 ‘$’ 后面跟一个用标准C语言表示的整数；
2. **寄存器（register）**：表示某个寄存器的内容，用符号 $r_a$ 表示任意寄存器 $a$，用引用 $R[r_a]$ 表示它的值，这是将寄存器集合看成一个数组 $R$，用寄存器**标识符**作为引索；
3. **内存引用**：根据计算出来的地址（通常称为有效地址）访问某个内存的位置。因为将内存看成一个很大的字节数组，可以用符号 $M_b[Addr]$ 表示对存储在内存中从地址 $Addr$ 开始的 $b$ 个字节的引用。图中最下面一种寻址模式表示的有效地址被计算为：$Imm+R[r_b]+R[r_i]*s$，其中 $s$ 只能取1、2、4和8。

![操作数指示符](..\images\CSAPP\image4.png)

#### 数据传送指令

**MOV类**：指令把数据从源位置复制到目的位置，不做任何变化。**MOV类** 由四条指令组成：**movb、movw、movl、movq**，它们的区别在于操作的数据大小不同。

源操作数指定的值是一个立即数，储存在寄存器中或者内存中。目的操作数指定的是一个位置，要么是一个寄存器，要么是一个内存地址。传送指令的两个操作数不能都指向内存地址。将一个值从内存位置复制到另一个内存位置需要两条指令，第一条指令将源值加载到寄存器中，另一条指令将寄存器值写入目的位置。

图中最后一条指令是处理 64位 立即数数据的。常规的 **movq** 指令只能以表示为 32位 补码数字的立即数作为源操作数，然后把这个值符号拓展为 64位 的值，放到目的位置。**movabsp** 指令能以任意 64位 立即数值作为源操作数，并且只能以寄存器作为目的。

![MOV类指令](..\images\CSAPP\image5.png)

下面是另外两类数据移动指令，在将较小的源值复制到较大的源值时使用。**MOVZ类**中的指令把目的中剩余的字节填充为 0，而**MOVS类**中的指令通过符号拓展来填充，把源操作的最高位进行复制。其中 **cltq** 指令没有操作数，它总是以寄存器 **%eax** 作为源，**%rax** 作为符号拓展结果的目的。它的效果与指令 **movslq %eax %rax** 完全一致，不过编码更紧密。

![MOVZ](..\images\CSAPP\image6.png)

![MOVS](..\images\CSAPP\image7.png)

最后两个数据传送指令可以将4字数据压入程序栈中，以及从程序栈中弹出数据。这两个指令只有一个操作数，分别是**压入的数据源**和**弹出的数据目的**。压入栈时，首先要将栈指针减8，然后将新值写到栈顶地址；弹出栈时，首先将栈顶值复制到目的，然后将栈指针加8。它们分别等价于以下指令：

``` console
subq $8, %rsp
movq %rbp, (%rsp)

movq (%rsp), %rax
addq $8, %rsp
```
![压入和弹出栈数据](..\images\CSAPP\image8.png)

#### 算术和逻辑操作

下面是一些整数和逻辑操作指令，每类指令有各种带不同操作数的变种，操作的数据分别是字节、字、双字和四字。这些指令操作被分为四组：**加载有效地址、一元操作、二元操作和位移**。

![算术和逻辑操作](..\images\CSAPP\image9.png)

1. 加载有效地址：

加载有效地址（load effective address）指令 **leaq** 实际上是 **movq** 指令的变形，它的指令形式是从内存读数据到寄存器，但实际上它**根本就没有引用内存**，而是将有效地址写入到目的操作数。这条指令可以为内存引用产生指针，另外，它还可以简洁地描述普通的算数运算。例如，如果寄存器 **%rdx** 的值为 **x**，那么指令 **leaq 7(%rdx, %rdx, 4), %rax** 将 **%rax** 的值设置为 **5x + 7**。**目的操作数必须是一个寄存器。**

2. 一元和二元操作

第二组中的操作是一元操作，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存地址。

第三组是二元操作，其中，第一个操作数可以是立即数、寄存器或地址；第二个操作数既是源又是目的。注意，当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。

3. 位移操作

最后一组操作是位移操作，先给出位移量，然后第二项给出的时要位移的数。可以进行算数位移和逻辑位移。位移量可以是一个立即数，或者放在单字节寄存器 **%cl** 中，并且只允许以这个特定的寄存器作为操作数。由于一个字节编码可以达到 255，所以有一个特殊的规则使得位移量不会超过数据的位数。左移操作的效果是一样的，而右移操作分为逻辑右移和算术右移。

4. 特殊的算数操作

**imulq** 指令有两种不同的形式。其中一种是双操作数乘法指令，它从两个64位操作数中产生一个64位乘积。另一种是单操作乘法指令，以计算两个64位值的全128位乘积——一个是无符号乘法，一个是补码乘法。这两条指令都要求一个参数必须在寄存器 **%rax** 中，而另一个操作数作为指令的源操作数给出。然后乘积存放在寄存器 **%rdx(高64位)** 和 **%rax(低64位)** 中。

除法或取余操作是由单操作数除法指令提供的。有符号除法指令 **idivl** 将寄存器 **%rdx(高64位)** 和 **%rax(低64位)** 中的128位操作数作为被除数，而除数作为指令的操作数给出。指令将商存储在寄存器 **%rax** 中，将余数存储在寄存器 **%rdx** 中。 

对于大多数64位的除法操作中，除数也常常是一个64位的值。这个值应该存放在 **%rax** 中，**%rdx** 的位应该设置全为0（无符号运算）或者 **%rax** 的符号位（有符号运算）。这个操作可以用指令 **cqto** 来完成。这条指令不需要操作数，它隐含读出 **%rax** 的符号位。并将它复制到 **%rdx** 的所有位。
 
![特殊的算术操作](..\images\CSAPP\image10.png)

### 控制

#### 条件码

除了整数寄存器，CPU还维护着一组单个位的条件码（condition code）寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器的值来执行条件分支指令。最常用的条件码有：

1. **CF**：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。
2. **ZF**：零标志。最近的操作得出的结果为0。
3. **SF**：符号标志。最近的操作得到的结果是负数。
4. **OF**：溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。

**leaq** 指令不改变任何条件码，因为它是用来进行地址计算的。除此之外，图3-10和下图中的所有指令都会设置条件码。**CMP指令**根据两个操作数之差来设置条件码，除了只设置条件码而不更新目的寄存器外，**CMP指令**与**SUB指令**的行为是一样的。同样，**TEST指令**和**AND指令**一样，只设置条件码而不改变目的寄存器的值。

![比较和测试指令](..\images\CSAPP\image11.png)

#### 访问条件码


条件码通常不会直接读取，常用的使用方法有3种：1）可以根据条件码的某种组合，将一个字节设置为0或1，2）可以跳转到程序的某个其他的部分，3）可以有条件地传送数据。对于第一种情况，下图所示的指令根据条件码的某种组合，将一个字节设置为0或1。这类指令被称为**SET**指令，它们的区别在于它们考虑的条件码的组合。**SET**指令的目的操作数是地位单字寄存器元素之一，或者是一个字的内存位置，指令会将这个字节设置为0或1。

![SET指令](..\images\CSAPP\image12.png)


#### 跳转指令


![跳转指令](..\images\CSAPP\image13.png)

正常执行的情况下，指令按照它们出现的顺序一条一条地执行。跳转 **(jump)** 指令会导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号（label）指明。**jmp** 指令是无条件跳转。它可以是直接跳转， 即跳转目标是作为指令的一部分编码的；也可以是间接跳转，即跳转目标是从寄存器或内存位置中读出的。例如，指令`jump *%rax`用寄存器 **%rax** 中的值作为跳转目标；而指令`jump *(%rax)`以 **%rax** 中的值作为读地址，从内存中读出跳转目标。表中所示的其他跳转指令都是有条件的，它们根据条件码的某种组合，或者跳转，或者继续执行代码序列中下一条指令。这些指令的名字和跳转条件与 **SET** 指令的名字和设置条件是相匹配的。

#### 跳转指令的编码

在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。跳转指令有几种不同的编码，但是最常用都是 **PC 相对的 (PC-relative)**。也就是，它们会将**目标指令的地址**与**紧跟在跳转指令后面那条指令的地址**之间的差作为编码。这些地址偏移量可以编码为1、2或4个字节。第二种编码方法是给出“绝对“地址，用4个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码。

建议用 **rep** 后面跟 **ret** 的组合来避免使 **ret** 指令成为条件跳转指令的目标。


#### 用条件传送来实现条件分支

实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代处理器上，它可能会非常低效替代的策略是使用数据的条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。只有在一些受限制的情况中，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理器的流水线的性能特性。

![用条件传送来实现条件分支](..\images\CSAPP\image14.png)

#### 循环

语言提供了多种循环结构，即do-while、while、for 。汇编中没有相应的指令存在，可以用条件测试和跳转组合起来实现循环的效果。

1. do-while
![do-while](..\images\CSAPP\image15.png)

2. while
![while](..\images\CSAPP\image16.png)
![for](..\images\CSAPP\image17.png)

3. for：for循环通常采用上述两种循环规则的其中一种。

#### switch语句

switch（开关）语句可以根据一个整数索引值进行多重分支 (multiway branching)在处理具有多种可能结果的测试时，这种语句特别有用。它们不仅提高了代码的可读性，而且通过使用跳转表 (jump table) 这种数据结构使得实现 加高效 。跳转表是一个数组，表项是一个代码段的地址，这个代码段实现当开关索引值等千 时程序应该采取的动作。程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。和使用一
组很长的if-else语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数最无关。

![switch](..\images\CSAPP\image18.png)

### 过程

**过程**是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。设计良好的软件用**过程**作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值，**过程**会对程序状态产生什么样的影响。不同编程语言中，过程的形式多样：函数(function) 、方(method) 、子例(subroutine) 、处理函数(handler) 等等，但是它们有一些共有的特性。要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程调用过程Q, 执行后返回到。这些动作包括下面一个或多个机制：

**传递控制**：在进入过程Q的时候，程序计数器必须被设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。

**传递数据**：必须能够向Q提供一个或多个参数， 必须能够向P返回一个值。

**分配和释放内存**：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。

#### 运行时栈 

程序可以用栈来管理它的**过程**所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。当P调用Q时，控制和数据信息添加到栈尾。当P返回时，这些信息会释放掉。

当 x86-64 **过程**需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为**过程的栈帧** (stack fram) 。

#### 转移控制

将控制从函数P转移到函数P要简单地把程序计数器(PC)设置为Q 的代码的起始位。不过，当稍后从Q返回的时候，处理器必须记录好它需要继续P的执行的代码位置。在x86-64机器中，这个信息是用指**call Q**调用过程Q来记录的。该指令会把地址A压入栈中，并将PC设置为Q的起始地址。压入的地址A被称为返回址，是紧跟在**call**指令后面的那条指令的地址。对应的指令 **ret**从栈中弹出地址A, 并把PC设置为A。

![call指令](..\images\CSAPP\image19.png)

call指令有一个目标，即指明被调用过程起始的指令地址。同跳转一样，调用可以是直接的，也可以是间接的。在汇编代码中，直接调用的目标是一个标号，而间接调用的目标是 * 后面跟一个操作数指符。

#### 数据传送

当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。在x86-64 中，大部分过程间的数据传送是通过寄存器实现的。例如，我们已经看到无数的函数示例，参数在寄存器 **%rdi、%rsi** 和其他寄存器中传递 。当P过程 调用过程Q时，P的代码必须首先把参数复制到适当的寄存器中。类似地，当Q返回到P时，P的代码可以访问寄存器 **%rax** 中的返回值。如果一个函数有大于6个整型参数，超出6个的部分就要通过栈来传递。

![数据传送](..\images\CSAPP\image20.png)

#### 栈上的局部存储

不过有些时候，局部数据必须存放在内存中，常见的情况包括：

• 寄存器不足够存放所有的本地数据。

• 对一个局部变量使用地址运算符 ＆，因此必须能够为它产生一个地址。

• 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。

一般来说，过程通过减小栈指针在栈上分配空间，分配的结果作为栈帧的一部分，标号为“局部变量”。

#### 寄存器中的局部存储空间

寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此，x86-64用了一组统一的寄存器使用惯例，所有的过程（包括程序库）都必须遵循。 

根据惯例，寄存器 **%rbx %rbp %r12~%r15** 被划分为被调用者保存寄存器。当过程P调用过程Q时，必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标号为“保存的寄存器”的一部分。有了这条惯例，P的代码就能安全地把值存在被调用者保存寄存器中（当然，要先把之前的值保存到栈上），调用Q，然后继续使用寄存器中的值，不用担心值被破坏。

所有其他的寄存器，除了栈指针 **%rsp**, 都分类为调用者保存寄存器。这就意味着任何函数都能修改它们。可以这样来理解“调用者保存”这个名字：过程P在某个此类寄存器中有局部数据，然后调用过程Q。因为Q可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是P（调用者）的责任。

寄存器和栈的惯例使得 x86-64 过程能够递归地调用它们自身。每个过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量不会相互影响。此外，栈的原则很自然地就提供了适当的策略，当过程被调用时分配局部存储，当返回时释放存储。

递归调用一个函数本身与调用其他函数是一样的。栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息（保存的返回值和被调用者保存寄存器的值）存储空间。如果需要，它还可以提供局部变量的存储。栈分配和释放的规则很自然就与函数调用－返回的顺序匹配。

### 数组的分配和访问

#### 基本原则

x86-64 的内存引用指令可以用来简化数组访问。例如，假设E是一个int型的数组，而我们想计算E[i], 在此，E的地址存放在寄存器 **%rdx** 中，而i存放在寄存器 **%rcx** 中。然后,指令`movl (%rdx, %rcx, 4) ,eax`会执行地址计算 $X_E+4i$, 读这个内存位置的值，并将结果存放到寄存器**%eax** 中。允许的伸缩因子1、2、4、8覆盖了所有基本简单数据类型的大小。

#### 指针运算

扩展一下前面的例子，假设整型数组E的起始地址和整数索引i分别存放在寄存器 **%rdx %rcx** 中。下面是一些与E有关的表达式。我们还给出了每个表达式的汇编代码实现，结果存放在寄存器 **%eax**（如果是数据）或寄存器 **%rax**（如果是指针）中。

![指针运算](..\images\CSAPP\image21.png)

### 浮点代码

处理器的**浮点体系结构**包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上，包括：

• 如何存储和访问浮点数值：通常是通过某种寄存器方式来完成。

• 对浮点数据操作的指令。

• 向函数传递浮点数参数和从函数返回浮点数结果的规则。

• 函数调用过程中保存寄存器的规则——例如，一些寄存器被指定为调用者保存，而其他的被指定为被调用者保存。

AVX 浮点体系结构允许数据存储在16个**YMM**寄存器中，它们的名字为%**ymm0~%ymm15**。每个**YMM**寄存器都是 256位（32字节）。当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低32位（对于float）或64位（对于 double）。汇编代码用寄存器的 **SSE XMM** 寄存器名字 **%xmm0~%xmm15**来引用它们，每个**XMM**寄存器都是对应的**YMM**寄存器的低128位（16字节）。

![浮点寄存器](..\images\CSAPP\image22.png)

#### 浮点传送和转换操作

下图给出了一组在内存和**XMM寄存器**之间以及从一个**XMM寄存器**到另一个不做任何转换的传送浮点数的指令。引用内存的指令是标量指令，意味着它们只对单个而不是一组封装好的数据值进行操作。数据要么保存在内存中要么保存在**XMM寄存器**中。无论数据对齐与否，这些指令都能正确执
行，不过代码优化规则建议32位内存数据满足4字节对齐，64位数据满足8字节对齐。内存引用的指定方式与整数**MOV指令**的一样，包括偏移、基址寄存器、变址寄存器和伸缩因子的所有可能的组合。

![浮点传送和转换操作](..\images\CSAPP\image23.png)

GCC只用标量传送操作从内存传送数据到**XMM寄存器**或从 **XMM寄存器**传送数据到内存。对于在两个**XMM寄存器**之间传送数据， GCC会使用两种指令之一，即用**vmovaps**传送单精度数，用**vmovapd**传送双精度数。对于这些情况，程序复制整个寄存器还是只复制低位值既不会影响程序功能，也不会影响执行速度，所以使用这些指令还是针对标量数据的指令没有实质上的区别。指令名字中的字母‘a’表示 aligned（对齐的）。当用于读写内存时，如果地址不满足 16字节对齐，它们会导致异常。在两个寄存器之间传送数据，绝不会出现错误对齐的状况。

下图给出了在浮点点数和整数数据类型之间以及不同浮点格式之间进行转换的指令集合。这些都是对单个数据值进行操作的标量令。图3-47中的指令把一个从**XMM寄存器**或内存中读出的浮点值进行转换，并将结果写入一个通用寄存器（例如**%rax、%ebx**等）。把浮点值转换成整数时，指令会执行截断 (truncation), 把值向下进行舍入，这是C语言和大多数其他编程语言的要求。

![浮点操作](..\images\CSAPP\image24.png)

图3-48中的指令把整数转换成浮点数，它们使用的是不太常见的三操作数格式，有两个源和一个目的。第一个操作数读自于内存或一个通用目的寄存器。这里可以忽略第二个源操作数，因为它的值只会影响结果的高位字节，而我们的目标必须是**XMM寄存器**。在最常见的使用场景中，第二个源和目的操作数都是一样的，就像这条指令：`vcvtsi2sdq %rax, %xmm1, %xmm1`。


#### 浮点数运算操作

图3-49描述了一组执行算术运算的标量AVX2浮点指令每条指令有一个(S1)或两个(S1, S2) 源操作数，和一个目的操作数。第一个源操作数S1可以是一个**XMM寄存器**或一个内存位置。第二个源操作数和目的操作数都必须是**XMM寄存器**。每个操作都有一条针对单精度的指令和一条针对双精度的指令。结果存放在目的寄存器中。

和整数运算操作不同，AVX浮点操作不能以立即数值作为操作数。相反，编译器必须为所有的常量值分配和初始化空间。然后代码在把这些值从内存读入。

![浮点数运算操作](..\images\CSAPP\image25.png)


#### 在浮点代码中使用位级操作

有时，我们会发现GCC生成的代码会在**XMM寄存器**上执行位级操作，得到有用浮点结果。下图展示了一些相关的指令，类似于它们在通用寄存器上对应的操作。这些操作都作用于封装好的数据，即它们更新整个目的**XMM寄存器**，对两个源寄存器的所有位都实施指定的位级操作。

![浮点代码的位级操作](..\images\CSAPP\image26.png)

#### 浮点比较操作

![浮点比较操作](..\images\CSAPP\image27.png)

条件码的设置条件：

![条件码的设置条件](..\images\CSAPP\image28.png)

其中，PF是奇偶标准位。对于整数操作，当最近一次算术或逻辑运算产生的值的最低字节是偶校验的（即这个字节中有偶数个1），那么就会设置这个标志位。对于浮点数比较，当浮点数中任意一个是NaN时，会设置该位。

## 第四章 处理器体系结构

### Y86-64指令集体系架构

#### 程序员可见的状态

如图4-1所示，Y86-64程序中的每条指令都会读取或修改处理器状态的某些部分。这称为程序员可见状态，这里的”程序员”既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器。在处理器实现中，只要我们保证机器级程序能够访问程序员可见状态，就不需要完全按照ISA暗示的方式来表示和组织这个处理器状态。Y86-64的状态类似x86-64。

内存从概念来说是一个很大的字节数组，保存着程序和数据，硬件和操作系统联合起来将虚拟地址翻译成实际或物理地址，指明数据实际存在内存中哪个地方。

程序状态的最后一个部分是状态码**Stat**，它表明程序执行的总体状态，正常运行或是出现了某种异常。

![Y86指令体系架构](..\images\CSAPP\image29.png)

#### Y86-64指令

![Y86-64指令](..\images\CSAPP\image30.png)

#### 指令编码

每条指令需要1~10个字节不等，这取决于需要哪些字段。每条指第一个字节表明指令的类型，这个字节分为两个部分，每部分位：高4位是代码 (code) 部分，低4位是功(function)部分。

指令集的一个重要性质就是字节编码必须有唯一的解释。给定这个字节，我们就可以决定所有其它附加字节的长度和含义。即使代码嵌入到其他程序中，只要从序列的第一个字节开始处理，任然可以很容易的确定指令序列。

早期RISC和CISC指令的区别：

![早期RISC和CISC指令的区别](..\images\CSAPP\image31.png)


### 逻辑设计和硬件控制语言HCL

### Y86-64的顺序实现

#### 将处理组织成阶段

通常，处理一条指令包括很多操作。将它们组织成某个特殊的阶段序列，即使指令的动作差异很大，但所有的指令都遵循统一的序列。每一步的具体处理取决于正在执行的指令。创建这样一个框架，我们就能够设计一个充分利用硬件的处理器。下面是关于各个阶段以及各阶段内执行操作的简略描述：

• 取指(fetch) : 取指阶段从内存读取指令字节，地址为程序计数器 (PC) 的值。从指令中抽取出指令指示符字节的两个四位部分，称为icode（指令代码）和ifun（指令功能）。它可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数指示符rA和rB 。它还可能取出一个四字节常数字valC 。它按顺序方式计算当前指令的下一条指令的地址valP也就是说，valP等于PC的值加上已取出指令的长度。

• 译码(decode): 译码阶段从寄存器文件读入最多两个操作数，得到值valA 和／或 valB，通常，它读入指令rA和rB字段指明的寄存器，不过有些指令是读寄存器%rsp的。

• 执行(execute): 在执行阶段，算术／逻辑单元 (ALU) 要么执行指令指明的操作（根据ifun的值），计算内存引用的有效地址，要么增加或减少栈指针。得到的值我们称为 valE。在此，也可能设置条件码。对一条条件传送指令来说，这个阶段会检验条件码和传送条件（由ifun给出），如果条件成立，则更新目标寄存器。同样，对一条跳转指令来说，这个阶段会决定是不是应该选择分支。

• 访存(memory): 访存阶段可以将数据写入内存，或者从内存读出数据。读出的值为valM。

• 写回(write back) : 写回阶段最多可以写两个结果到寄存器文件。

• 更新PC(PC update): PC设置成下一条指令的地址。

处理器无限循环，执行这些阶段。从前面的讲述可以看出，执行一条指令是需要进行很多处理的。我们不仅必须执行指
令所表明的操作，还必须计算地址、更新栈指针，以及确定下一条指令的地址。幸好每条指令的整个流程都比较相似。因为我们想使硬件数量尽可能少，并且最终将把它映射到一
个二维的集成电路芯片的表面，在设计硬件时，一个非常简单而一致的结构是非常重要的。降低复杂度的一种方法是让不同的指令共享尽量多的硬件。

![MOV指令](..\images\CSAPP\image32.png)

![控制转移指令](..\images\CSAPP\image33.png)

同对整数操作一样，我们能够以一种统一的方式处理所有的跳转指令，因为它们的不同只在于判断是否要选择分支的时候。除了不需要一个寄存器指示符字节以外，跳转指令在取
指和译码阶段都和前面讲的其他指令类似。在执行阶段，检查条件码和跳转条件来确定是否要选择分支，产生出一个一位信号Cnd 。在更新PC阶段，检查这个标志，如果这个标志为1, 就将PC设为valC（跳转目标），如果为0, 就设为 valP（下一条指令的地址）。


我们创建了一个统一的框架，能处理所有不同类型的 Y86-64指令。虽然指令的行为大不相同，但是我们可以将指令的处理组织成6个阶段。现在我们的任务是创建硬件设计来实现这些阶段，并把它们连接起来。


#### SEP（指令译码器）硬件结构

硬件单元与各个处理阶段相关联：

取指：将程序计数器寄存器作为地址，指令内存读取指令的字节。PC增加器 (PC incrementer) 计算valP, 即增加了的程序计数器。

译码：寄存器文件有两个读端口A和B,从这两个端口同时读寄存器值valA和valB。

执行：执行阶段会根据指令的类型，将算术／逻辑单元 (ALU) 用于不同的目的。对整数操作，它要执行指令所指定的运算。对其他指令，它会作为一个加法器来计算增加或减
少栈指针，或者计算有效地址，或者只是简单地加0, 将一个输入传递到输出。

条件码寄存器 (CC) 有3个条件码位。ALU负责计算条件码的新值。当执行条件传送指令时，根据条件码和传送条件来计算决定是否更新目标寄存器。同样，当执行一条跳转指令时，会根据条件码和跳转类型来计算分支信号Cnd。

访存：在执行访存操作时，数据内存读出或写入一个内存字。指令和数据内存访问的是相同的内存位置，但是用于不同的目的。

写回：寄存器文件有两个写端口。端口E用来写ALU计算出来的值，而端口M用来写从数据内存中读出的值。


PC更新：程序计数器的新值选择自：valP，下一条指令的地址；valE, 调用指令或跳转指令指定的目标地址；valM，从内存读取的返回地址。


![SEQ硬件结构](..\images\CSAPP\image34.png)

- 白色方框表示时钟寄存器：程序计数器PC是SEQ唯一的时钟寄存器。
- 浅蓝色方框表示硬件单元：这包括内存、ALU 等等。在我们所有的处理器实现中，都会使用这一组基本的单元。我们把这些单元当作"黑盒子＂，不关心它们的细节设计。
- 控制逻辑块用灰色圆角矩形表示：这些块用来从一组信号源中选择，或者用来计算布尔函数。
- 路线的名字在白色圆圈中指明：它们只是路线的标识，而不是什么硬件单元。
- 宽度为字长的数据连接用中等粗度的线表示：每条这样的线实际上都代表一簇64根线，并列地连在一起，将一个字从硬件的一个部分传送到另一部分。
- 宽度为字节或更窄的数据连接用细线表示：根据线上要携带的值的类型，每条这的线实际上都代表一簇4根或8根线。
- 单个位的连接用虚线来表示：这代表芯片上单元于块之间传递的控制值。

#### SEQ的时序

SEQ的实现包括组合逻辑和两种存储器设备：时钟寄存器（程序计数器和条件码寄存器），随机访问存储器（寄存器文件、指令内存和数据内存）。组合逻辑不需要任何时序或
控制，只要输入变化了，值就通过逻辑门网络传播。正如提到过的那样，我们也将读随机访问存储器看成和组合逻辑一样的操作，根据地址输入产生输出字。对于较小的存储器
来说（例如寄存器文件），这是一个合理的假设，而对于大的电路来说，可以用特殊的时钟电路来模拟这个效果。由于指令内存只用来读指令，因此我们可以将这个单元看成是组
合逻辑。

#### SEQ阶段的实现

### 流水线的通用原理

#### 计算流水线

#### 流水线操作的详细说明

#### 流水线的局限性

#### 带反馈的流水线系统

### Y86-64的流水线实现


## 第五章 优化程序性能

### 优化编译器的能力和局限性

## 第六章 存储器层次结构


### 存储技术

#### 随机访问存储器

随机访问存储器（Random Access Memory）分为两类，静态的和动态的。静态RAM（SRAM）比动态RAM（DRAM）快，但是也贵得多。SRAM用来作为高速缓存存储器，DRAM主要用来作为主存以及图形系统的帧缓冲区。一个桌面系统的SRAM 不会超过几兆字节，但是DRAM却有几百或几千兆字节。


1. 静态RAM

SRAM将每个位存储在一个双稳态的 (bistable) 存储器单元里。每个单元是用一个六晶体管电路来实现的。这个电路有这样一个属性，它可以无限期地保持在两个不同的电压配置 (configuration) 或状态 (state) 之一。其他任何状态都是不稳定的。从不稳定状态开始，电路会迅速地转移到两个稳定状态中的一个，类似于倒转的钟摆。由于SRAM具有双稳态形式，只要有点，它就会永远保持它的值，即使有干扰干扰到电压，只要干扰消除，电路就会恢复到稳定值。

2. 动态RAM

DRAM将每个位存储为对一个电容的充电。与SRAM同， DRAM存储器单元对干扰非常敏感。当电容的电压被扰乱之后，它就永远不会恢复了。暴露在光线也下会导致电容电压改变。实际上，数码照相机和摄像机中的传感器本质上就是DRAM单元的阵列。

![RAM](..\images\CSAPP\image35.png)

3. 传统的DRAM

传统的DRAM芯片被组织成$r*c$的矩阵形式，矩阵中的每个元素代表一个字节（8位）。芯片有8个data引脚，用来传送一个字节到芯片或从芯片传出一个字节。还有两个addr引脚，它们携带2位的行和列矩阵地址信息，先将行地址数据转换到复制到内部行缓冲区，接下来内存控制器发送列地址存储的字节数据。

![DRAM结构](..\images\CSAPP\image36.png)

4. 内存模块

一个内存模块的基本思想是采用多个DRAM芯片，当内存模块读入一个地址时，它实际上读取的是每个DRAM的一个字节，最后将多个字节合成一个作为实际的输出。

![内存模块](..\images\CSAPP\image37.png)

5. 增强的DRAM

6. 非易失性存储器

断电后，DRAM和SRAM会丢失它们的数据，这称为易失性存储器（volatile）。相反的，非易失性存储器能够在断电后仍然保存它们的信息。由于历史原因，ROM中有的类型既可以读又可以写，但它们仍然被称为只读存储器（Read Only Memory）。EEPROM（Electrically Erasable Programmable ROM）不需要物理上一个独立编程的设备，它能够被编程的次数的数量级达到$10^5$。

闪存是基于EEPROM的非易失性存储器，而固态硬盘（Solid State Disk，SSD）是基于闪存的非易失性存储器。

存储的ROM设备中的程序被称为固件（firmware）。当一个计算机系统通电以后，它会运行存储在ROM中的固件（例如BiOS）。

7. 访问主存

数据流通过称为总线（bus）的共享电子电路在处理器和DRAM主存之间来来回回。每次CPU和主存之间的数据传送都是通过一系列步骤来完成的。这些步骤称为总线事务（bus transaction），总线事务又分为从主存传送数据到CPU的读事务（read transaction）和从CPU传送数据到主存的写事务（write transaction）。

CPU内部被称为IO桥接器（I\O Bridge）的芯片组（其中包含内存控制）与主存通过总线连接起来，其中一条总线是系统总线，它连接CPU和I\O桥接器，另一条是内存总线，它连接I\O桥接器和主存。

当需要将内存中的数据传到寄存器时，CPU先的数据的地址放到总线上，I\O桥将数据传递到内存总线，然后主存通过地址读取到数据，将数据发送到总线上，CPU再将数据读取复制的寄存器上。

#### 磁盘存储

1. 磁盘构造

2. 磁盘容量

3. 磁盘操作

4. 逻辑磁盘块

5. 连接I\O设备

通用串行总线 (Universal Serial Bus, USB) 控制器是一个连接到USB总线的设备的中转机构， USB总线是一个广泛使用的标准，连接各种外围I/0设备，包括键盘、鼠标、调制解调器、数码相机、游戏操纵杆、打印机、外部磁盘驱动器和固态硬盘。USB3.0总线的最大带宽为625MB，USB3.1总线的最大带宽为1250MB。

另外，主机总线适配器将一个或多个磁盘设备连接到I\O总线。

6. 访问磁盘

CPU使用一种称为内存映射I/O(memory-mapped I/0)的技术来向 I/0 设备发送命令。在使用内存映射I/0的系统中，地址空间中有一块地址是为与I/0设备通信保留的。每个这样的地址称为一个I/0端口(I/0 port)当一个设备连接到总线时，它与一个或多个端口相关联（或它被映射到一个或多个端口）。

#### 固态硬盘

### 局部性

#### 对程序数据引用的局部性

#### 取指令的局部性

### 存储器层次结构

#### 存储器层次结构中的缓存


存储器层次结构的中心思想是，对于每个k, 位于k层的更快更小的存储设备作为位于k+l层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一层都缓存来自较低一层的数据对象。第k层的存储器被划分成较少的块的集合，每个块的大小与k+l层的块的大小一样。在任何时刻第k层的缓存包含第k+l层块的一个子集的副本。

1. 缓存命中

当程序需要第k层的某个数据对象d时，它首先在当前存储在第k层的一个块中查找d。如果k刚好缓存在第k层中，那么就是我们所说的缓存命中 (cache hit) 该程序直接从第层读取d，根据存储器层次结构的性质，这要比从第k+l层读取d更快。

2. 缓存不命中

另一方面，如果第k层中没有缓存数据对象d, 那么就是我们所说的缓存不命中(cache miss) 当发生缓存不命中时，第k层的缓存从第k+1层缓存中取出包含d的那个块，如果第k层的缓存已经满了，可能就会覆盖现存的一个块。

覆盖一个现存的块的过程称为替换 (replacing) 或驱逐 (evicting) 这个块。被驱逐的这个块有时也称为牺牲块 (victim block) 。决定该替换哪个块是由缓存的替换策略 (replacement policy) 来控制的。例如，一个具有随机替换策略的缓存会随机选择一个牺牲块。一个具有最近最少被使用（LRU） 替换策略的缓存会选择那个最后被访问的时间距现在最远的块。在第k层缓存从第k+1层取出那个块之后，程序就能像前面一样从第k层读出d了。

3. 缓存不命中的种类

区分不同种类的缓存不命中有时候是很有帮助的。如果第k层的缓存是空的，那么对任何数据对象的访问都会不命中。一个空的缓存有时被称为冷缓存 (cold cache)，此类不命中称为强制性不命中 (compulsory miss) 或冷不命中 (cold miss) 。冷不命中很重要，因为它们通常是短暂的事件，不会在反复访问存储器使得缓存暖身 (warmed up) 之后的稳定状态中出现。只要发生了不命中，第k层的缓存就必须执行某个放置策略 (placement policy), 确定把它从第k+1层中取出的块放在哪里。最灵活的替换策略是允许来自第k+l层的任何块放在第k层的任何块中。对于存储器层次结构中高层的缓存（靠近 CPU）, 它们是用硬件来实现的，而且速度是最优的，这个策略实现起来通常很昂贵，因为随机地放置块，定位起
来代价很高。因此，硬件缓存通常使用的是更严格的放置策略，这个策略将第k+l层的某个块限制放置在第k层块的一个小的子集中（有时只是一个块）。


这种限制性的放置策略会引起一种不命中，称为冲突不命中 (conflict miss)，在这种情况中，缓存足够大，能够保存被引用的数据对象，但是因为这些对象会映射到同一个缓存块，缓存会一直不命中。程序通常是按照一系列阶段（如循环）来运行的，每个阶段访问缓存块的某个相对稳定不变的集合。例如，一个嵌套的循环可能会反复地访问同一个数组的元素。这个块的集合称为这个阶段的工作集 (working set) 。当工作集的大小超过缓存的大小时 缓存会经历容量不命中 (capacity miss) 。换句话说就是，缓存太小了，不能处理这个工作集。

4. 缓存管理

正如我们提到过的，存储器层次结构的本质是，每一层存储设备都是较低一层的缓存。在每一层上，某种形式的逻辑必须管理缓存。这里，我们的意思是指某个东西要将缓
存划分成块，在不同的层之间传送块，判定是命中还是不命中，并处理它们。管理缓存的逻辑可以是硬件、软件，或是两者的结合。

### 高速缓存存储器

#### 通用的高速缓存存储器组织结构

#### 直接映射高速缓存

#### 组相联高速缓存

### 编写高速缓存友好代码

### 综合：高速缓存对程序性能的影响

## 第七章 链接


### 编译器驱动程序

`linux> gcc -o prog main.c sum.c`

**预处理器（cpp，c preprecessor）：**

`linux> cpp -o main.i main.c`

`linux> gcc -E -o main.i main.c`

选项`-E`限制编译器只进行预处理，不进行编译、汇编及链接的操作。

**编译器（cc，c compiler）：**

`linux> cc -S -o main.s main.i`

`linux> gcc -S -o main.s main.i`

编译器将预处理后的文件转化为汇编语言。选择`-S`表示只对文件进行编译，不做汇编及链接的处理。

**汇编器（as，assembler）：**

`linux> as -o main.o main.i`

汇编器将汇编语言转化为机器语言，生成可重定位目标文件。

**链接器（ld）：**

`linux> ld -static -o prog main.o sum.o [system object files]`

链接操作就是将可重定位目标文件以及必要的系统文件结合起来，生成一个可执行文件。

最后，**shell**调用一个叫做**加载器（loader）**的程序，它将可执行文件中的代码和数据复制到内存，然后将控制转移到这个程序的开头。

`linux> ./prog`

![编译器驱动程序](..\images\CSAPP\image38.png)

### 静态链接

为了构造可执行文件，链接器必须完成两个主要任务：

- 符号解析：目标文件定义和引用符号，每个符号对应一个函数、一个全局变量或一个静态变量。**符号解析的目的是将一个符号引用正好和一个符号定义关联起来。**
- 重定位：编译器和汇编器生成从地址0开始的代码和数据节（section）。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条（relocation entry）的详细指令，不加甄别地执行这样的重定位。


### 可重定位目标文件

![可重定位目标文件](..\images\CSAPP\image39.png)

ELF（Executable and Linkable Format）Header：ELF头展示了可执行目标文件的基本信息，可以用指令`linux> readelf -h main.o`查看。

夹在ELF头和节头部表之间的都是节（section），一个典型的ELF文件包含以下节，可以用指令`linux> readefl -S main.o`查看：

- .text：已编译程序的机器代码，可以用反汇编工具将机器代码转化为汇编代码：`objdump -s -d main.o`
- .rodate：只读数据，例如printf语句中的格式化语句和switch语句中的跳转表
- .data：已初始化的全局和静态C变量。局部C变量（未初始化）保存在栈中，即不出现在.data节中，也不出现在.bss节中
- .bss（better save space）：未初始化的全局和静态C变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为0
- .symtab：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息
- .rel.text： 一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置
- .rel.date：被模块引用或定义的所有全局变最的重定位信息
- .debug：一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。只有以-g选项调用编译器驱动程序时，才能得到这张表
- .line：原始C源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译器驱动程序时，才会得到这张表
- .strtab：一个字符串表，其内容包括.symtab debug节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列

### 符号表

每个可重定位目标文件都有一个符号表，可以用指令查看符号表的内容：`linux> readelf -s main.o`

符号类型：

- 全局符号（Global Symbols）
- 外部符号（Externals Symbols）
- 局部符号（Local Symbols）


### 符号解析

链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对于定义在相同模块的局部符号的引用，符号解析的规则是只允许每个模块中只有一个定义。

对于全局符号的引用解析，当编译器遇到一个未在当前模块定义的符号时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号条目表，并把它交给链接器。如果链接器在它输入的任何一个模块中都找不到这个被引用符号的定义，链接器就会抛出一个错误。

如果多个模块定义重名的符号，编译器会采用一下机制：在编译时，编译器向汇编器输出每个全局符号，或者是强 (strong)或者是弱(weak)，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。根据强弱符号的定义，链接器使用以下规则来处理多重定义的符号：

- 规则1：不允许有多个重名的强符号
- 规则2：如果有一个强符号和多个弱符号同名，那么选择强符号
- 规则3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个

### 与静态库链接

C使用标准库的一种方法是，把所有的C标准函数都放在一个单独的可重定位目标模块中，可以把这个模块链接的程序中，但是这样做过于浪费空间也不利于库的更新和维护。

`linux> gcc main.c /usr/lib/libc.o`

也可以将每个标准函数创建一个独立的可重定位目标文件，把它放在一个众所周知的目录中。但是这样容易出错。

`linux> gcc main.c /usr/lib/printf.o`

于是，静态库的概念被提了出来。在连接时，链接器只复制被程序引用的目标模块，从而减小目标文件在磁盘和内存中的大小。另一方面，应用程序只需要包含较少的库文件的名字，例如**libc.a**。

在linux系统在，静态库以一种存档（.a，archive）的格式存储在磁盘中。

生成静态库需要使用**ar**工具：

`linux> gcc -c main.o main.c`

`linux> ar rcs libfun.a func1.o func2.o`

`linux> gcc -static -o prog main.o libfun.a`

或者：

`linux> gcc -o prog main.c lib.a`

![静态库](..\images\CSAPP\image40.png)

### 重定位

一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义（即它的一个输入目标模块中的一个符号表条目）关联起来。此时，**链接器就知道它的输入目标模块中的代码节和数据节的确切大小**。现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成：

- 重定位节和符号定义：在这一步中，链接器将所有相同类型的section合并为同一类型的新聚合节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了
- 重定位节中的符号引用：在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目(relocation entry)的数据结构，我们接下来将会描述这种数据结构。

#### 重定位目标条目

当汇编器生成 个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变最的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text，已初始化数据的重定位条目放在.rel.data中。

### 动态链接共享库

静态库解决了许多关于如何让大量相关函数对应用程序可用
的问题。然而，静态库仍然有一些明显的缺点。静态库和所有的软件一样，需要定期维护和更新。如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式地将他们的程序与更新了的库重新链接。

另一个问题是几乎每C程序都使用标准I/O函数，比如printf和scanf 。在运行时，这些函数的代码会被复制到每个运行进程的文本段中，在一个运行上百个进程的典型系统上，这将是对稀缺的内存系统资源的极大浪费。

共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接(dynamic linking)，是由一个叫做动态链接器(dynamic linker)的程序来执行的。共享库也称为共享目标(shared object)，Linux系统中通常用.so后缀来表示。微软的操作系统大最地使用了共享库，它们称为DLL（动态链接库）。

![动态链接库](..\images\CSAPP\image41.png)

共享库是以两种不同的方式来“共享”的。首先，在任何给定的文件系统中，对于一个库只有一个.so文件。所有引用该库的可执行目标文件共享这个.so文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中其次，在内存中，一个共享库的.text节的一个副本可以
被不同的正在运行的进程共享。

`linux> gcc -shared -fpic -o lib.so addvec.c mulvec.c`

其中，`-fpic`选项表示编译器生成与位置无关的代码。

`linux> gcc -o prog main.c lib.so`

基本的思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。认识到这一点是很重要的：此时，没有任何让libbvector.so的代码和数据节真的被复制到可执行文件prog中。反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对libvector.so中代码和数据的引用。


当加载器加载和运行可执行文件prog时，加载部分链接的可执行文件prog。接着，它注意到prog包含一个.interp节，这一节包含动态链接器的路径名，动态链接器本身就是一个共享目标（如在Linux系统上的ld-linux.so），加载器不会像它通常所做地那样将控制传递给应用，而是加载和运行这个动态链接器。然后，动态链接器通知执行下面的重定位完成链接任务：

- 重定位libc.s的文本和数据到某个内存段。
- 重定位libvector.so的文本和数据到另一个内存段
- 重定位prog中所有对由libc.so和libvector.so定义的符号的引用。

最后，动态链接器将控制传递给应用程序。从这个时刻开始，共享库的位置就固定了，并且在程序执行的过程中都不会改变。


### 处理目标文件的工具

`linux> ar`：创建静态库，插入、删除、列出和提取成员。

`linux> strings`：列出1个目标文件中所有可打印的字符串。

`linux> strip`：从目标文件中删除符号表信息。

`linux> nm`：列出一目标文件的符号表中定义的符号。

`linux> size`：列出目标文件中节的名字和大小。

`linux> readelf`：显示一个目标文件的完整结构，包括 ELF头中编码的所有信息。包含size和nm功能。

`linux> objdump`：所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编.text节中的二进制指令。

`linux> ldd`：列出一个可执行文件在运行时所需要的共享库。

## 第八章 异常控制流

### 异常

异常（exception）就是控制流中的突变，用来响应处理器中状态的某些变化。在处理器中，状态被编码为不同的位和信号。状态变化称为事件（event）。

在任何情况下，操作系统检测到异常时，会通过一张叫做异常表（exception table）的跳转表，进行一个间接的过程调用，跳转的一个专门设计的系统子系统（异常处理器）。当处理器处理完异常后，会根据引起异常的类型，发生一下三种类型之一：

- 处理程序将控制返回给异常发生的指令
- 处理程序将控制返回给下一条指令
- 处理程序终止被中断的程序


系统为每种可能的异常都分配了唯一的非负异常号，其中一些异常号是由处理器设计者分配的，其他号码是由操作系统决定的。在系统启动时，操作系统会分配和初始化一张异常跳转表，表目包含异常处理程序的地址。


![异常的类别](..\images\CSAPP\image42.png)

### 进程

**Linux**内部的`/proc`文件系统，允许用户模式进程访问内核数据结构的内容。`/proc`文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件层次结构，例如CPU类型（`/proc/cpuinfo`）。

操作系统内使用一种称为上下文切换的高层形式的异常控制流来实现多任务。

### 系统调用的错误处理

错误包装处理函数。对于一个给定的基本函数foo, 我们定义一个具有相同参数的包装函数Foo, 但是第一个字母大写。包装函数调用基本函数，检查错误，如果有任何问题就终止。


### 进程控制

**Unix**系统提供了大量的操作进程系统调用的函数。

**获取进程ID：**
```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
pid_t getppid(void);
```

**创建和终止进程：**
```c
#include <stdlib.h>

void exit(int status);
```

父进程通过以下函数创建一个子进程：
```c
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
```

新创建的子进程**几乎但不完全**与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用**fork**时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在千它们有不同的**PID**。

**fork**被调用一次，却会返回两次。一次是在父进程中，另一次是在子进程中。在子进程中，返回0，因为子进程总是非0，所以需要提供一个标识来判断它是子进程。

父进程与子进程是并发地执行。

当一个进程由于某种原因终止时，系统并不是立即把它清除。相反，系统会使他处于一种终止状态，直到它被父进程**回收**。一个终止了但未被回收的进程被称为僵死进程。

如果一个进程终止了，内核会安排**init**进程成为它的孤儿进程的养父。如何父进程没有回收它的僵死子进程就终止了，那么内核就会安排**init**进程去回收它们。

一个进程可以通过**waitpid**函数来等待它的子进程终止或停止。参数`status`返回一个状态信息。

```c
#include <sys/types.h> 
#include <sys/wait.h> 

pid_t waitpid(pid_t pid, int *statusp, int options);
```

**wait**函数是**waitpid**函数的简单版本，`wait(&status)`相当于调用`waitpid(-1, &status, 0)`。

```c
#include <sys/types.h> 
#include <sys/wait.h> 

pid_t wait(int *status);
```

**sleep**程序让进程挂起指定一段时间。

```c
#include <unistd.h> 

unsigned int sleep(unsigned int secs);
```

另一个有用的函数是**pause**函数，该函数让调用的函数休眠，直到该进程收到一个信号。

```c
#include <unistd.h> 

int pause(void);
```

**execve**函数在当前进程的上下文中加载并运行一个新程序。

```c
#include <unistd.h> 
int execve(const char *filename, const char *argv[], const char *envp[]);
```

**execve**函数加载并运行可执行目标文件**filename**, 且带参数列表**argv**和环境变量列表**envp**。只有当出现错误时，例如找不到**filename**, **execve**才会返回到调用程序。所以，与**for**k一次调用返回两次不同，**execve**调用一次并从不返回。

**Linux**提供了几个函数来操作环境数组：

**getenv**函数在环境数组中搜索字符串"name=value"，如果找到了，它就返回一个指向**value**的指针，否则它就返回**NULL**。

```c
#include <stdlib.h> 

char *getenv(const char *name);
```
***sb的梦是真的sb***

如果环境数组包含一个形如"name=oldvalue" 的字符串，那么**unsetenv**会删除它，而**setenv**会用**newvalue**代替oldvalue，但是只有在**overwirte**非零时才会这样如果**name**不存在，那么**setenv**就把"name=newvalue"添加到数组中。

```c
#include <stdlib.h> 

int setenv(const char *name, const char *newvalue, int overwrite); 
void unsetenv(const char *name);
```

实现一个简单的**shell**程序。

### 信号


本节将研究一种更高层的软件形式的异常，称为**Linux信号**，**它允许进程和内核中断其他进程**。一个信号就是一条小消息，它通知进程系统发生了一个某种类型的事件。

![信号](..\images\CSAPP\image43.png)


传送一个信号到目的进程由两个不同的步骤组成：

- **发送信号**：内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送信号有以下两种原因，要么是检测到一个系统事件，比如说除零错误或子进程终止，要么是一个进程调用了**kill**函数，显示地要求内核发送一个信号给进程。一个进程可以发送信号给它自己。

- **接收信号**：当进程强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者执行一个称为**信号处理程序**的用户层函数捕获这个信号。

一个发出而没有被接收的信号叫做**待处理信号*（pending signal）。在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都不会排队等待；它们只是被简单地丢弃。一个进程可以有选择性地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。


一个待处理信号最多只能被接收一次。内核为每个进程在 **pending** 位向量中维护着待处理信号的集合，而在 **blocked** 位向量中维护被阻塞的信号集合。只要传送了一个型为k的信号，内核就会设置 **pending** 中的第k位，而只要接收了一个类型为k的信
，内核就会清除 **pending** 中的第k位。


**发送信号**

**Unix**系统提供了大量向进程发送信号的机制，所以这些机制都是基于进程组的概念的。

每个进程都属于一个进程组，进程组由一个正整数ID标识。**getpgrp**返回进程的进程组ID。

```c
#include <unistd.h> 

pid_t getpgrp(void);
```

默认地，子进程和父进程同属一个进程组。一个进程可以通过**setpgid**函数改变自己或其他进程的进程组。

```c
#include <unistd.h> 

int setpgid(pid_t pid, pid_t pgid);
```

该函数将进程**pid**的进程组改为**pgid**，如果**pid**是0，则使用当前进程的**pid**。如果**pgid**是0，则使用**pid**指定的进程的**PID**作为进程组**ID**。

**Unix shell**使用作业（job）这个抽象概念来表示为对一条命令行求值而创建的进程。任何时刻，至多只有一个前台作业和0个或多个后台作业。**shell**为每一个作用创建一个独立的进程组。

在键盘上输入**Ctrl+C** 会导致内核发送一个**SIGINT信号**到前台进程组中的每个进程。默认情况下，结果是终止前台作业。类似地，输入**Ctrl+Z**会发送一个**SIGTSTP信号**到前台进程组中的每个进程。默认情况下，结果是停止（挂起）前台作业。


使用**kill**指令发送信号到其他进程或自己：

```c
#include <sys/types.h> 
#include <signal.h> 

int kill(pid_t pid, int sig);
```

若**pid**为0，则发送信号给**调用进程所在组**的每个进程，包括调用进程自己。若**pid**小于0，发送信号给**进程组**中的每个进程，不包括自己。


进程可以通过调用**alarm**函数向它自己发送**SIGALRM信号**。

```c
#include <unistd.h> 

unsigned int alarm(unsigned int secs);
```

进程可以通过使用**signal**函数修改和信号相关联的默认行为。唯一的例外是**SIGSTOP和SIGKILL**，它们的默认行为是不能修改的。

```c
#include <signal.h> 
typedef void (*sighandler_t)(int); 

sighandler_t signal(int signum, sighandler_t handler);
```


**signal**函数可以通过下列三种方来改变和信 **signum**相关联的行为：

- 若**handler**是**SIG_IGN**，那么忽略类型为**signum**的信号。
- 若**handler**是**SIG_DFL**，那么类型为**signum**的信号行为恢复为默认行为。
- 否则，**handler**就是用户定义的函数的地址，这个函数被称为**信号处理程序**，只要进程接收到某个类型为**signum**的信号，就会调用这个程序。通过把处理程序的地址传递到**signal**函数从而改变默认行为，这叫做**设置信号处理程序（installing the handler）**。调用信号处理程序被称为**捕获信号**。执行信号处理程序被称为**处理信号**。


阻塞和接触阻塞信号。




### 非本地跳转

C语言提供了一种用户级异常控制流形式，称为非本地跳转（nonlocal jump），它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用－返回序列。

```c
#include <setjmp.h> 

int setjmp(jmp_buf env); 
int sigsetjmp(sigjmp_buf env, int savesigs);
```


## 第九章 虚拟内存

虚拟内存提供了三个重要的能力： 

- 它将主存看成是一个存储在磁盘上的地址空间的
高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。

- 它为每个进程提供了一致的地址空间，从而简化了内存管理。

- 它保护了每个进程的地址空间不被其他进程破坏。


### 物理和虚拟内存

**物理寻址**：计算机的主存被组织为一个字节数组，从0开始，每个字节有唯一的编号。通过这个编号来找到字节的方法被称为物理寻址。

**虚拟寻址**：计算机通过生成一个虚拟地址来访问主存。这个虚拟地址需要经过**地址翻译**的操作转换为物理地址，**地址翻译**需要CPU硬件和操作系统的紧密结合。CPU芯片上叫做**内存管理单元（Memory Management Unit，MMU）**的专用硬件，利用存放在主存中的**查询表**来动态翻译虚拟地址，该表的内容由操作系统管理。

### 地址空间

地址空间是一个**非负整数集合**。如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间。CPU从一个有$N=2^n$个地址的地址空间中生成虚拟地址，这个地址空间被称为虚拟物理空间。

一个地址空间的大小是由表示最大地址所需要的位数来描述的。例如，一个包$N=2^n$个地址的虚拟地址空间就叫做一个n位地址空间。现代系统通常支持32位或者64位虚拟地址空间。

一个系统还有一个物理地址空间，对应于物理地址的字节。


### 虚拟内存作为缓存的工具

概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组，每字节都有一个唯一的虚拟地址，作为到数组的索引。**磁盘上数组的内容被缓存在主存中**。

和存储器层次结构中其他缓存一样，磁盘（较低层）上的数据被分割成块，这些块作为磁盘和主存（较高层）之间的传输单元。VM系统通过将虚拟内存分割为称为虚拟页（Virtual Page, VP）的大小固定的块来处理这个问题。每个虚拟页的大小为$P=2^p$字节。类似地，物理内存被分割为物理页（Physical Page，PP），大小也为$P=2^p$字节。


### 案例：Linux内存系统


每个进程都有一个独立的页表，对应一个独立的虚拟地址空间。系统使用多级页表，以减小页表占据的空间。



## 第十章 系统级I/O


### Unix I/O


所有的I/O设备，例如网络、磁盘和终端，都被模型化为文件，而所有的输入和输出对应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单的、低级的应用接口，称为**Unix I/O**，这使得所有输入和输出都能以一种统一且一致的方式执行：

- **打开文件**：应用程序要求内核打开一个文件，宣告它要访问一个I/O设备。内核返回一个非负整数，叫做**描述符**，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息，应用程序只需要记住这个描述符。
- **Linux Shell**创建的每个进程开始时都有3个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。头文件**<unistd.h>**定义了常量STDIN_FILENO、STDOUT_FILENO和STRERR_FILENO，它们可以用来代替显示的描述符值。
- 改变当前文件的位置：对于打开的文件，内核保持着一个文件位置k，初始为0，作为文件开头其实字节的偏移量。应用程序能够通过执行**seek**操作，显示地设置的当前位置为k。
- **读写文件**：一个读操作就是从文件复制**n>0**个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k>=m时会触发一个称为**EOF**的条件，应用程序能够检测到这个条件。在文件结尾处并没有明确的**EOF**符号。类似的，写操作就是从内存复制**n>0**个字节到文件，然后更新k值。
- **关闭文件**：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论 个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。

### 文件

### 打开和关闭文件

进程时通过**open**函数打开或者创建一个文件的：

```c
#include <sys/types.h> 
#include <sys/stat.h> 
#include <fcntl .h> 

int open(char *filename, int flags, mode_t mode); 
```

返回：若成功则为新文件描述符，失败则返回-1。**flags**参数指明了以何种方式打开这个文件。

- **O_RDONLY**：只读
- **O_WRONLY**：只写
- **O_RDWR**：可读可写

**flags**参数也可以是一个或多位掩码的或，为写提供一些额外的提示：

- **O_CREAT**：如果文件不存在，就创建它的一个截断的（truncated）（空）文件
- **O_TRUNC**：如何文件存在，就截断它
- **O_APPEND**：每次写操作前，设置文件位置到文件的结尾处

**mode**参数指定了新文件的访问权限位。作为上下文的一部分，每个进程都有一个**umask**，它是通过调用**umask**函数来设置的。当进程通过某个带有**mode**参数的**open**函数来创建一个文件时，文件的访问权限位被设置为**mode & ~umask**。

![文件访问权限位](..\images\CSAPP\image44.png)

最后，进程通过**close**函数关闭一个文件，并且关闭一个已经关闭的文件描述符会出错。

```c
#include <unistd.h> 

int close(int fd);
```

#### 读和写文件

应用程序分别是通过调用**read**和**write**函数来执行输入和输出的：

```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t n); 
ssize_t write(int fd, const void *buf, size_t n);
```

若成功则返回读的字节数，若**EOF**则为0，若出错则为-1。

**read**函数从描述符为**fd**的当前文件位置复制最多**n**个字节到内存位置**buf**。返回值-1表示一个错误，而返回值0表示**EOF**。否则，返回值表示的是实际传送的字节数量。

**write**函数从内存位置**buf**复制至多**n**个字节到描述符**fd**的当前文件位置。


### 用RIO（Robust I/O）包壮实地读写

**RIO**包会自动处理不足值。**RIO**提供了两类不同的函数：

- 无缓存的输入输出函数：这些函数直接在内存和文件之间传送数据，没有应用级缓冲。它们对将二进制数据读写到网络和从网络中读写二进制数据尤其有用。
- 带缓冲的输入函数：这些函数允许你高效地从文件中读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内，类似于为**printf**这样的标准**I/O**函数提供的缓冲区。并且，带缓冲的**RIO**输入函数是线程级安全的，它在同一个描述符可以交错地调用。例如，你可以从一个描述符中读一些文本行，然后读取一些二进制数据，接着再多读取一些文本行。


通过调用**rio_readn**和**rio_writen**函数，应用程序可以在内存和文件之间直接传送数据。

#### RIO的无缓冲的输入输出函数

```c
ssize_t rio_readn(int fd, void *usrbuf, size_t n); 
ssize_t rio_writen(int fd, void *usrbuf, size_t n);
```

返回：若成功则返回读的字节数，若**EOF**则为0，若出错则为-1。


**rio_readn**函数从描述符**fd**的当前文件位置最多传送**n**个字节到内存位置**usrbuf**。类似地，**rio_writen**函数从位置**usrbuf**传送**n**个字节到描述符**fd**。**rio_read**函数在遇EOF时只能返回一个不足值。**rio_writen**函数决不会返回不足值。对同一个描述符，可以任意交错地调用**rio_readn**和**rio_writen**。


#### RIO的带缓冲的输入函数


计算一个文本文件中文本行的个数，一种方式实时调用**read**函数一次一个字节地从文件传送数据到内存。这种方法的缺点是效率不高，而且没读取一个字节都要求陷入内核。

一种更好的方式是使用包装函数**rio_readlineb**。


### 读取文件元数据

应用文件能够通过调用**stat**和**fstat**函数，检测到有关文件的信息（有时也称为文件元数据（metadata））。

```c
#include <unistd.h> 
#include <sys/stat.h> 

int stat(const char *filename, struct stat *buf); 
int fstat(int fd, struct stat *buf);
```

**stat**函数以一个文件名作为输入，并填写一些结构体。**fstat**函数与之相似，只不过以文件描述符作为输入。

![stat](..\images\CSAPP\image45.png)

**st_size**包含文件字节数，**st_mode**则编码了文件访问许可位和文件类型，用宏谓词来确定**st_mode**成员的文件类型：

```c
#include <sys/stat.h>

//S_ISREG(m)    这是一个普通文件吗？
//S_ISDIR(m)    这是一个目录文件吗？
//S_ISSOCK(m)   这是一个网络套接字吗？
//S_ISURR(m)    这是一个可读文件吗？
```


### 读取目录内容

可以使用**readdir**系列函数来读取目录内容。

```c
#include <sys/types.h> 
#include <dirent.h> 

DIR *opendir(const char *name);
```

函数opendir以路径名为参数，返回指向目录流的指针。流是对条目有序列表的抽象，在这里指目录项的列表。


```c
#include <dirent.h> 

struct dirent *readdir(DIR *dirp);

struct dirent { 
ino_t d_ino;         /* Inode number 文件位置*/ 
char d_name[256];    /* Filename 文件名*/ 
};
```


每次对**readdir**的调用返回的都是指向流**dirp**中下一个目录项的指针，或者，如果没有更多目录项则返回**NULL** 。每个目录项都是一个结构题，有以上的数据项。


关闭文件夹：

```c
#include <dirent.h> 

int closedir(DIR *dirp);
```


### 共享文件


内核用三个相关的数据结构来表示打开的文件：

- **描述符表**：每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。
- **文件表**：打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成（针对我们的目的）包括当前的文件位置、引用计数（reference count）（即当前指向该表项的描述符表项数），以及一个指向**v-node表**中对应表项的指针。关闭一个描述符会减少相应的文件表表项中的引用计数。内核不会删除这个文件表表项，直到它的引用计数为零。
- **v-node表**：同文件表一样，所有的进程共享这**v-node表**。每个表项包含**stat结构**中的大多数信息，包括**st_mode和st_size**成员。


![文件描述表](..\images\CSAPP\image46.png)


### I/O重定向


```c
#include <unistd.h> 

int dup2(int oldfd, int newfd);
```

**dup2**函数复制描述符表表项**oldfd**到描述符表表项**newfd**，覆盖描述符表表项**newfd**以前的内容。如果**newfd**已经打开了，**dup2**会在复制**oldfd**之前关闭**newfd**。


### 标准I/O


C语言定义了一组高级输入输出函数，称为标准I/O库，为程序员提供了**Unix I/O**的较高级别的替代。这个库（libc）提供了打开和关闭文件的函数 **（fopen fclose）**、读和写字节的函数 **（fread fwrite）**、读和写字符串的函数 **（fgets fputs）**, 以及复杂的格式化的I/O函数 **（scanf printf）**。


标准C库将一个打开的文件模型化为一个流。对于程序员而言，一个流就是一个指**FILE 类型**的结构的指针。每个ANSI程序开始时都有三个打开的流**stdin stdout
stderr**，分别对应于标准输入、标准输出和标准错误：

![标准I/O](..\images\CSAPP\image47.png)


## 第十一章 网络编程

所有的网络应用都是基于相同的基本编程模型，有着相似的逻辑结构，并且使用相同的编程接口。


### 客户端-服务器编程模型

每个网络应用都是基于**客户端-服务器模型**的。采用这个模型，一个应用是由**一个服务器进程**和一**个或多个客户端进程组成**。服务器管理某种资源，并且通过操作这种资源来为它的客户提供某种服务。例如，一个Web服务器管理着一组磁盘文件，它会代表客户端进行检索和执行。一个ftp服务器管理着一组磁盘文件，它会为客户端进程存储和检索。一个电子邮件服务器管理着一些文件，它为客户端进程读和更新。

客户端-服务器基本模型中的基本操作是**事务（transaction）**。一个客户端-服务器事务由以下四步组成：

- 当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务。例如，当Web浏览器需要一个文件时，它就发送一个请求给Web服务器。
- 服务器收到请求后，解释它，并以适当的的方式操作它的资源。例如，当Web服务器发出请求后，它就读一个磁盘文件夹。
- 服务器给客户端发送一个响应，并等待下一个请求。例如，Web服务器将文件发送回客户端。
- 客户端收到响应并处理它。例如，当Web浏览器收到来自服务器的一页后，就在屏幕上显示此页。

![客户端-服务器模型](..\images\CSAPP\image48.png)

认识的客户端和服务器是进程，而不是机器或主机，这是很重要的。一台主机可以同时运行多个客户端和服务器，而且一个客户端或服务器的事务可以在不同主机上运行。

### 网络


对主机而言，网络是一种I\O设备，是数据源和数据接收方。

物理上而言，网络是一个按照地理远近组成的层次结构。最底层是**局域网（LAN，local area network）**，一个建筑或校园范围内。最流行的局域网技术是**以太网（Ethernet）**。


一个**以太网段（Ethernet segment）**包括一些**电缆**和一个叫做**集线器**的小盒子。以太网段通常跨越一些小的区域，例如建筑物的某个区域或者一个楼层。没条电缆都有相同的最大位带宽，通常是100Mb/s或1Gb/s，一端连接到主机的适配器，而另一端连接到集线器的一个端口上。集线器会不加分辨地将一个端口上收到的每个位复制到其他所有端口上，因此，每台主机都能看到每个位。

每个以太网适配器都有一个全球唯一的48位地址，它存储在这个适配器的非易失存储器上。一台主机可以发送一**段位（称为帧（frame））**到这个网段内的其他任何主机。每个帧包括一些固定数量的**头部（header）**，用来标识此帧的**源和目的地址**以及此帧的长度，此后紧随的就是数据位的**有效荷载（payload）**。每个主机适配器都能看到这个帧，当时只有目的主机实际读取它。

使用一些电缆和叫做**网桥（bridge）**的小盒子，多个以太网段可以连接成较大的局域网，称为**桥接以太网（bridged Ethernet）**。桥接以太网能够跨越整个建筑或者校区。在一个桥接以太网里，一些电缆连接网桥与网桥，而另外一些连接网桥与集线器。它们的带宽可以是不同的。


![桥接以太网](..\images\CSAPP\image49.png)


网桥比集线器更充分得利用了电缆带宽，利用一种聪明的分配算法，它们随时间自动学习哪个主机可以通过哪个端口到达，然后只有在必要时，有选择地将帧从一个端口复制到另一个端口。因此局域网可以化简为以下模型：

![局域网概念视图](..\images\CSAPP\image50.png)

在更高层次级别中，多个不兼容的局域网可以通过叫做 **路由器（router）** 的特殊计算机连接起来，组成一个**互联网络（Internet）**。每台路由器对于它所连接到的每个网络都有一个**适配器（端口）**。由路由器连接起来的网络称为**广域网（WAN，Wide-area Network）**。

互联网的重要机制是，它能由采用完全不同和不兼容技术的各种局域网和广域网组成。运行在每台主机和路由器上都有一种相同的软件协议，它消除了不同网络之间的差异，这种协议控制主机和路由器如何协同工作来实现数据传输。这种协议必须提供两种基本能力：

- 命名机制：不同的局域网技术有不同和不兼容的方式来为主机分配地址。互联网络协议通过定义一种一致的主机地址格式消除了这些差异。每台主机会被分配至少一个这种**互联网络地址（internet address）**，这个地址唯一地标识了这台主机。
- 传送机制：在电缆上编码位和将这些位封装成帧方面，不同的联网技术有不同的和不兼容的方式。互联网络协议通过定义一种把数据位捆扎成不连续的片（称为包）的统一方式，从而消除了这些差异。一个包是由包头和有效栽荷组成的，其中包头包括包的大小以及源主机和目的主机的地址，有效载荷包括从源主机发出的数据位。


### 全球IP英特网
 
英特网的客户端和服务器混合使用**嵌套字接口函数和Unix I/O函数**来进行通信。通常套接字函数实现为系统调用，这些系统调用会陷入内核，并调用各种内核模式的**TCP/IP函数**。

在IP地址结构体中存放的地址总是以（大端法）网络字节顺序存放的，即使主机字节顺序是小端法。Unix提供了下面的函数在网络和主机字节顺序之间实现转化。

```c
#include <arpa/inet.h> 
/*返回：按照网络字节顺序的值*/
uint32_t htonl(uint32_t hostlong); 
uint16_t htons(uint16_t hostshort); 
/*返回：按照主机字节顺序的值*/
uint32_t ntohl(uint32_t netlong); 
uint16_t ntohs(unit16_t netshort);
```

应用程序用**inet_pton**和**inet_ntop**函数来实现IP地址和点分十进制串之间的转换。

```c
#include <arpa/inet.h> 
/*返回：若成功则为1, src为非法点分十进制地址则为0, 若出错则为-1*/
int inet_pton(AF_INET, const char *src, void *dst); 
/*返回：若成功则指向点分十进制字符串的指针，若出错则为 NULL*/
const char *inet_ntop(AF_INET, const void *src, char *dst, socklen_t size); 
```

在这些函数名中，**n**代表网络，**p**代表表示，它们可以处理32位的**IPv4地址（AF_INET）**，也可以处理64位的**IPv6地址（AF_INET6）**。



### 套接字接口

**套接字接口（socket interface）**是一组函数，它们和Unix I/O函数结合起来，用以创建网络应用。

![套接字接口](..\images\CSAPP\image51.png)


客户端和服务器使用**socket函数**创建一个套接字描述符。

如果想要使套接字成为连接的一个端点，就用如下硬编码的参数来调用**socket函数**：

```c
#include <sys/socket.h> 
/*返回：若成功则返回非负描述符，若出错则返回-1*/
int socket(int domain, int type, int protocol);

clientfd = Socket(AF_INET, SOCK_STREAM, 0);
```

`AF_INET`表示我们使用的是IPv4地址，而`SOCK_STREAM`表示这个套接字是连接的一个端点。



客户端通过使用**connect函数**来建立和服务器的连接。

```c
#include <sys/socket.h> 
/*返回：若成功则返回0，出错则为-1。*/
int connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen);
```


**connect函数**试图与套接字地址为**addr**的服务器建立一个因特网连接，其中**addrlen**为`sizeof(sockaddr_in)`。**connect函数**会阻塞，一直到连接成功建立或是发生错误。如果
成功，**clientfd描述符**现在就准备好可以读写了，并且得到的连接是由套接字对`(x, y addr.sin_addr:addr.sin_port`刻画的。对于**socket**, 最好的方法是用**getaddrinfo**来为**connect**提供参数。


剩下的套接字函数**bind listen accept**，服务器用它们来和客户端建立连接。

```c
#include <sys/socket.h> 
/*返回：若成功则返回0，出错则为-1。*/
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

**bind函数**告诉内核将**addr**中的服务器套接字地址和**套接字描述符sockfd**联系起来。参数**addrlen**就是`sizeof(sockaddr_in)`。**对于socket和connect**，最好的方法是用**getaddrinfo**来为**bind**提供参数。


服务器调用**listen函数**告诉内核，描述符是被服务器而不是客户端使用的。


```c
#include <sys/socket.h> 
/*返回：若成功则返回0，出错则为-1。*/
int listen(int sockfd, int backlog);
```

**backlog**参数暗示了内核在开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量


服务器通过调用**accept**函数来等待来自客户端的连接请求。

```c
#include <sys/socket.h> 
/*返回：若连接成功则返回非负连接描述符，若出错则为-1。*/
int accept(int listenfd, struct sockaddr *addr, int *addrlen);
```


**accept函数**等待来自客户端的连接请求到**达侦听描述符listenfd**, 然后在**addr**填写客户端的套接字地址，并返回一个已**连接描述符（connected descriptor）**, 这个描述符可被用来利用**Unix I/O函数**与客户端通信。


![网络通信](..\images\CSAPP\image52.png)

Linux提供了一些强大的函数**（getaddrinfo和getnameinfo）**实现二进制套接字地址结构和主机名、主机地址、服务名和端口号的字符串表示之间的相互转化。当和套接字接口一起使用时，这些函数能使我们编写独立于任何特定版本的IP协议的网络程序。

1. **getaddrinfo函数**

**getaddrinfor**函数将主机名、主机地址、服务名和端口号的字符串表示转化为套接字结构地址。

```c
#include <sys/types . h> 
#include <sys/socket.h> 
#include <netdb.h> 
int getaddrinfo(const char *host, const char *service, const struct addrinfo *hints, struct addrinfo **result); 
/*返回：如果成功则为 o, 如果错误则为非零的错误代码*/
void freeaddrinfo(struct addrinfo *result); 
const char *gai_strerror(int errcode);
```

给定**host**和**service**（套接字地址的两个组成部分），**getaddrinfo**返回**result**，**result**是一个指向**addrinfo**结构的链表，其中每个结构指向一个对应于**host**和**service**的套接字地址结构。

![结构](..\images\CSAPP\image52.png)

2. getnameinfo


#### Web服务器



## 第十二章 并发编程

### 基于进程的并发编程

### 基于I/O多路复用的并发编程

**select**函数会阻塞，要求内核挂起进程，只有在一个或多个I/O事件发生后，才将控制返回给应用程序。

```c
#include <sys/select.h> 
int select(int n, fd_set *fdset, NULL, NULL, NULL); 
//返回已准备好的描述符的非零的个数，若出错则为一 1,
FD_ZERO(fd_set•fdset);          /* Clear all bits in fdset */ 
FD_CLR(int fd, fd_set•fdset);   /* Clear bit fd in fdset */ 
FD_SET(int fd, fd_set•fdset);   /* Turn on bit fd in fdset */ 
FD_ISSET(int fd, fd_set•fdset); /* Is bit fd in fdset on? */

```


### 基于线程的并发编程

线程通过调用**thread_create函数**来创建其他线程。

```c
#include <pthread.h> 
typedef void *(func)(void *); 
int pthread_create(pthread_t *tid, pthread_attr_t *attr， func *f, void *arg);
 //成功返回非0，失败返回0
```

该函数创建一个新的线程并带着一个输入变量**arg**，在新线程的上下文中运行例程**f**，能用**attr**参数改变新创建线程的默认属性。默认使用NULL。

当该函数返回时，参数**tid**包含新创建线程的ID。新线程可以通过调用**pthread_self**函数来获得自己线程的ID。

```c
#include <pthread.h> 
//返回：调用者的线程ID
pthread_t pthread_self(void);
```

一个线程是以下列方式之一来终止的：

- 当顶层的线程例程返回时，线程会隐式地终止
- 通过调用**pthread_exit**函数，线程会显式地终止。如果主线程调用**pthread_ exit**，它会等待所有其他**对等线程**终止，然后再终止主线程和整个进程，返回值为**thread_return**

```c
#include <pthread.h> 

void pthread_exit(void *thread_return);
```

- 某个对等线程调用Linux的**exit函数**，该函数终止进程以及所有与该进程相关的线程
- 另一个对等线程通过以当前线程ID作为参数调用**pthread_cancel**函数来终止当前线程


```c
#include <pthread.h> 
//返回：成功返回0，失败返回非0
int pthread_cancel(pthread_t tid);
```

线程通过调用**pthread_join函数**等待其他线程终止。

```c
#include <pthread.h> 
//返回：成功返回0，失败返回非0
int pthread_join(pthread_t tid, void **thread_return);
```

**pthread_join函数会阻塞**，直到线程tid终止，将线程例程返回的通用(void*)指针赋值为**thread_return**指向的位置，然后回收己终止线程占用的所有内存资源。

注意，和Linux的**wait函数**不同， **pthread_join函数**只能等待一个指定的线程终止。**没有办法让pthread_wait等待任意一个线程终止**，这使得代码更加复杂，因为它迫使我们去使用其他一些不那么直观的机制来检测进程的终止。这是规范中的一个错误。


在任何一个时间点上，线程是可结合的 (joinable) 或者是分离的 (detached) 。一个可结合的线程能够被其他线程收回和杀死，在被其他线程回收之前，它的内存资源（例如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在它终
止时由系统自动释放。**默认情况下，线程被创建成可结合的**。为了避免内存泄漏，每个可结合线程都应该要么被其他线程显式地收回，要么通过调用**pthread_detach函数**被分离。

```c
#include <pthread.h> 
//返回：成功返回0，失败返回非0
int pthread_detach(pthread_t tid);
```

**pthread_detach函数**分离可结合线程tid。线程能够通过以**pthread self()**为参数的**pthread_detach**调用来分离它们自己。


初始化线程：函数**pthread_once**允许你初始化与例程线程相关的状态。

```c
#include <pthread.h> 
//返回：总是返回0
pthread_once_t once_control = PTHREAD_ONCE_INIT; 

int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));
```

**once_control变量**是一个**全局或者静态变量**，总是被初始化为**PTHREAD_ ONCE_ INIT**。当你第一次用参数**once_ control**调用**pthread_once**时，它调用**init_routine**，这是一个没有输入参数、也不返回什么的函数。接下来的以**once_control**为参数的**pthread_once**调用不做任何事情。无论何时，当你需要动态初始化多个线程共享的全局变量时，**pthread_once**函数是很有用的。



### 多线程程序中的共享变量


#### 线程内存模型

一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的线程上下文，包括线程ID、栈、栈指针、程序计数器、条件码和通用目的寄存器值。

每个线程和其他线程一起共享进程上下文的剩余部分。这包括整个用户虚拟地址空间，它是**由只读文本（代码）、读/写数据、堆以及所有的共享库代码和数据区域**组成的。线程也共享相同的打开文件的集合。

#### 将变量映射到内存

能被共享的变量：全局变量、本地静态变量（带static属性）、本地自动变量（不带static属性，可以通过局部指针变量引用，本质还是全局变量）。

### 用信号量同步线程

#### 使用信号量来同步线程

线程不应该交替地访问共享变量，也就是说，线程访问共享变量时应该**互斥**地执行。这个问题可以通过引入**信号量**来解决。


**信号量**是具有非负整数值的全局变量，只能由两个特殊的操作执行，这两种操作被抽象化为**P**和**V**：

- **P(s)**：如果**s**是非零的，那么**P**将**s**减1，并且立即返回。如果**s**为零，那么就挂起这个线程，直到**s**变为非零，而一个**V**操作会重启这个线程。在重启之后，P操作将**s**减1，并将控制返回给调用者。
- **V(s)**： **V**操作将**s**加1。如果有任何线程阻塞在 **P**操作等待**s**变成非零，那么**V**操作会重启这些线程中的一个，然后该线程将**s**减1, 完成它的**P**操作。

**P**中的**测试和减1**操作是不可分割的，也就是说，一旦预测信号量**s**变为非零，就会将**s**减1，不能有中断。**V**中的加1操作也是不可分割的，也就是加载、加1和存储信号量的过程中没有中断。注意，**V**的定义中没有定义等待线程被重启动的顺序。唯一的要求是**V**必须只能重启一个正在等待的线程。因此，当有多个线程在等待同一个信号量时，你不能预测**V**操作要重启哪一个线程。


**P和V**的定义确保了一个正在运行的程序绝不可能进入这样一种状态，也就是一个正确初始化了的信号量有一个负值。这个属性称为信号量不变性。


```c
#include <semaphore.h> 
//返回：成功返回0，出错返回-1
int sem_init(sem_t *sem, 0, unsigned int value); 
int sem_wait(sem_t *s); // P(s)  
int sem_post(sem_t *s); // V(s) 
```

**sem_init**函数将信号量**sem**初始化为**value**，每个信号量初始化之前必须初始化。对于我们的目的，中间变量总是为0。

信号量的基本思想是将每个共享变量（或者一组共享变量）与一个信号量（初始值为1）联系起来，然后用**P(s)**和**V(s)**操作将相应的临界区包围起来。**P操作**也称为互斥锁加锁，**V操作**称为互斥锁解锁。

#### 使用信号量来调度共享资源

场景：一个线程通过信号量来通知另一个线程，程序状态中的某个条件已经为真了。


**生产者-消费者问题**：生产者将生产品插入一个有限的缓冲槽中，消费者从缓冲槽中取出消费品进行消费。


除了对共享资源进行互斥操作之外，还需要调度对缓冲区的访问。如果缓冲区是满的（没有空的槽位），那么生产者必须等待直到有一个槽位变为可用。与之相似，如果缓冲区是空的（没有可取用的项目），那么消费者必须等待直到有一个项目变为可用。


**读者-写者**问题：


